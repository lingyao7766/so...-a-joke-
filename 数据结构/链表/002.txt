#include <stdio.h>
#include <stdlib.h>

typedef struct node
{
    int data;
    struct node *next;
}node;

int main()
{
    node *head,*p1,*p2,*p;
    int i;
    head = 0;

    for(i=1;i<5;i++)
    {
        p1=(node*)malloc(sizeof(node));
        (*p1).data=i;
        if(head == 0)
        {
            head = p1;
            p2=p1;
        }
        else
        {
            p2->next=p1;
            p2=p1;
        }
    }
    p2->next=0;

    //删除数据为2的链表结点
    p1=head;
    while(p1->data!=2)
    {
        p2=p1;
        p1=p1->next; //普通遍历，“2”出现之前p2都不变的意思
    }
    p2->next = p1->next;   //直接把p1的next指针赋给p2的next，实质上缩进了一个 存放着“2”的指针消失了
   // delete p1;  //delete是c++中常用的操作符，通常与new成对出现，作用是释放申请的内存空间。*注：在c文件中不能用
    free(p1);//呼呼太好了这个还是可以用（free是在c里的释放内存空间函数）

    //删除链表数据
    p = head;
    printf("链表上各节点的数据为：\n");
    while(p!=0)
    {
        printf("%d",p->data);
        p=p->next;
    }
    printf("\n");

return 0;
}








---------------------------------



#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

typedef struct node
{
    int data;
    struct node *next;
}node;

node *Create(void)  // 产生一条无序链表
{
	node *p1,*p2,*head;  // p2指向最后一个结点, p1指向插入结点，head指向头结点
	int a;
	head = 0;
	printf("产生一条无序链表，请输入数据，以-1结束：\n");
	scanf("%d",&a);
	 while(a!=-1) //这里就输入1,2,3,4,-1 *注：while函数后无分号..我可去他妈的吧、报错报的我折腾了一个多小时，cb还一点没有合理的提示...前前后后检查了三遍没想到居然会是这一行出问题？ 话说这一行出问题它报错报第29行干什么？？？25行就该受影响了吧？？？
    {
        p1 = (node *)malloc(sizeof(node));
        p1->data=a;
		if(head == 0)
        {
			head = p1;
			p2 = p1;
		}
        else
        {
            p2->next = p1;
            p2 = p1;
        }
        scanf("%d",&a);
	}


    if(head)
        p2->next = 0;
    return (head);
}

void Print(node *head)//输出链表各节点数据
{
    node *p;
    p = head;
    printf("链表上各结点数据为：\n");
    while(p!=0)
    {
        printf("%d",p->data);
        p=p->next;
    }
    printf("\n");
}

//删(删中实际上用到了查，查可能不难)
node *Delete_one_node(node *head,int num) //根据数据值删除链表中的一个结点
{
    node *p1,*p2;
    if(head == 0)
    {
        printf("链表为空，无结点可删除 \n");
        return 0;
    }
    if(head->data == num) //删除首结点
    {
        p1 = head;
        head = head->next;
        free(p1);
        printf("删除了一个结点\n");
    }
    else
    {
        p1 = head;
        p2 = head->next; //p1指向比较结点之前的一个结点
        while(p2->data != num && p2->next != 0) //找到要删除的结点（然后跳出循环）
            {
                p1 = p2;
                p2 = p2->next;
            }
            if(p2->data == num) //删除找到的结点
            {
                p1->next = p2->next;
                free(p2);
                printf("删除了一个结点\n");
            }
            else
                printf("链表上没有找到要删除的结点\n");
    }
    return head;
}

//增（暨插入数据到链表的任何一个位置当中）
node *Insert(node *head,node *p)//将一个结点插入链表中
{
    node *p1,*p2;
    if(head == 0)//若是空链表，插入链表首结点
    {
        head = p;
        p->next = 0;
        return head;
    }
    if(head->data >= p->data)//若非空链表，插入链表的首结点
    {
        p->next = head;
        head = p;   //把P接到头节点之后
        return head;
    }
    p2=p1=head;
    while(p2->next && p2->data < p->data)//找到要插入的位置
    {
        p1=p2;
        p2=p2->next;
    }
    if(p2->data < p->data) //插入链表尾
    {
        p2->next = p;
        p->next = 0;
    }
    else //插入在p1和p2所指向的结点之间
        {
            p->next = p2; //p2在P之后
            p1->next = p; //P1在P之前
        }
        return head;
}

node *Create_sort(void) //产生一条有序链表（从小到大）
{
    node *p1,*head = NULL;
    int a;
    printf("产生一条有序链表，请输入数据 以-1结束 \n");
    scanf("%d",&a);
    while(a!=-1)
    {
        p1=(node*)malloc(sizeof(node)); //产生一个新节点
        p1->data=a;
        head = Insert(head,p1);
        scanf("%d",&a);
    }
    return head;
}

void deletechain(node *head) //释放链表上各结点占用的内存空间
{
    node *p1;
    while(head)
    {
        p1=head;
        head = head->next;
        free((void *)p1);
    }
}



int main()   //这里类型是void的话即便没有return依然可行，但是会生出一条警告
{
    node *head;
    int num;

     head = Create(); //产生一条无序链表
    Print(head); //输出链表上各点的值

    printf("输入要删除结点上的一个整数\n");
    scanf("%d",&num);
    head=Delete_one_node(head,num); //删除链表上具有指定值的结点，只能删一个
    Print(head);

    node *p1 = (node *)malloc(sizeof(node));
    p1->data=4;
    head = Insert(head,p1);  //将新结点插入链表中
    Print(head);

    deletechain(head);  //释放整个链表的结点占用的内存空间

    head = Create_sort(); //产生一条有序链表 如1,3,2,5,-1
    Print(head);
    deletechain(head);  //释放链表上各结点占用的内存空间

return 0;
}
