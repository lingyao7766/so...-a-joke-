//#include <iostream>
#include <stdio.h>
#include <stdlib.h>
//#include <queue>

//using namespace std;
#define N 100
char *a="ABC##D#E##F##";

typedef struct node
{
    char data;
    struct node *lchild,*rchild;
}binnode;
typedef binnode *bintree;


//




-----------------------------------------------------------------
#include <stdio.h>

#include <stdlib.h>

//#include <queue>

#define N 100

char *a="ABC##D#E##F##";  /*扩充二叉树树t的前序序列*/

typedef struct node /*二叉树结构定义*/

{

    char data;

    struct node *lchild,*rchild;

} binnode;

typedef binnode *bintree;





/*函数creatbintree (根据扩充二叉树的前序序列(字符串a)建立二叉树t的存储结构*/

bintree  creatbintree()

{

    char ch=*a++;   // ch=*a ,a=a+1的缩写

    bintree t;

    if  (ch=='#')  t=NULL;

    else

    {

        t=(bintree)malloc(sizeof(binnode));

        t->data=ch;

        t->lchild=creatbintree();

        t->rchild=creatbintree();

    }

    return t;

}





void preorder(bintree t)  /*前序递归遍历二叉树*/

{

    if (t)

    {

        printf("%c",t->data);

        preorder(t->lchild);

        preorder(t->rchild);

    }

}

void inorder(bintree t)  /*中序递归遍历二叉树*/

{

    if (t)

    {


        inorder(t->lchild);

        printf("%c",t->data);

        inorder(t->rchild);

    }

}

void postorder(bintree t)  /*后序递归遍历二叉树*/

{

    if (t)

    {

        postorder(t->lchild);

        postorder(t->rchild);

        printf("%c",t->data);

    }

}



/*****************************************************************************************/

int main()

{

    bintree t;

    t=creatbintree();   /*建立二叉树t的存储结构*/

    printf("二叉树的前序序列为：\n");

    preorder(t);   /*前序遍历二叉树*/

    printf("二叉树的中序序列为：\n");

    inorder(t);   /*中序遍历二叉树*/

    printf("二叉树的后序遍历序列为：\n");

    postorder(t);   /*后序遍历二叉树*/

    return 0;

}






创建：
Node* createBinaryTree()
{
    Node *p;
    TelemType ch;
    cin>>ch;
    if(ch == 0)     //如果到了叶子节点，接下来的左、右子树分别赋值为0
    {
        p = NULL;
    }
    else
    {
        p = (Node*)malloc(sizeof(Node));
        p->data = ch;
        p->Left  = createBinaryTree();  //递归创建左子树
        p->Right = createBinaryTree();  //递归创建右子树
    }
    return p;
}

